1. Recursive Method

int minDepth(struct TreeNode* root) {
    if (root == NULL) return 0;

    if (root->left == NULL) return 1 + minDepth(root->right);

    if (root->right == NULL) return 1 + minDepth(root->left);

    int leftDepth = minDepth(root->left);
    int rightDepth = minDepth(root->right);
    return 1 + (leftDepth < rightDepth ? leftDepth : rightDepth);
}


2. Iterative BFS Method

#include <stdio.h>
#include <stdlib.h>

struct QueueNode {
    struct TreeNode* node;
    int depth;
    struct QueueNode* next;
};

void enqueue(struct QueueNode** head, struct TreeNode* node, int depth) {
    struct QueueNode* newNode = (struct QueueNode*)malloc(sizeof(struct QueueNode));
    newNode->node = node;
    newNode->depth = depth;
    newNode->next = NULL;
    if (*head == NULL) {
        *head = newNode;
    } else {
        struct QueueNode* temp = *head;
        while (temp->next) temp = temp->next;
        temp->next = newNode;
    }
}

struct QueueNode* dequeue(struct QueueNode** head) {
    if (*head == NULL) return NULL;
    struct QueueNode* temp = *head;
    *head = (*head)->next;
    return temp;
}

int minDepth(struct TreeNode* root) {
    if (root == NULL) return 0;

    struct QueueNode* q = NULL;
    enqueue(&q, root, 1);

    while (q != NULL) {
        struct QueueNode* front = dequeue(&q);
        struct TreeNode* node = front->node;
        int depth = front->depth;

        if (node->left == NULL && node->right == NULL) {
            return depth;
        }

        if (node->left) enqueue(&q, node->left, depth + 1);
        if (node->right) enqueue(&q, node->right, depth + 1);

        free(front);
    }
    return 0;
}

