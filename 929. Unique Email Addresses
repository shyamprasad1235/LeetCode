1. C Code

char* normalizeEmail(const char* email) {
    char* result = (char*)malloc(105 * sizeof(char)); 
    int i = 0, j = 0;

    while (email[i] != '@') {
        if (email[i] == '+') {
            while (email[i] != '@') i++;
            break;
        }
        if (email[i] != '.') {
            result[j++] = email[i];
        }
        i++;
    }
    while (email[i] != '\0') {
        result[j++] = email[i++];
    }
    result[j] = '\0';
    return result;
}

int numUniqueEmails(char** emails, int emailsSize) {
    char* unique[emailsSize];  
    int uniqueCount = 0;
    
    for (int i = 0; i < emailsSize; i++) {
        char* norm = normalizeEmail(emails[i]);

        int exists = 0;
        for (int k = 0; k < uniqueCount; k++) {
            if (strcmp(unique[k], norm) == 0) {
                exists = 1;
                break;
            }
        }
        
        if (!exists) {
            unique[uniqueCount++] = norm;
        } else {
            free(norm); 
        }
    }

    for (int i = 0; i < uniqueCount; i++) {
        free(unique[i]);
    }
    
    return uniqueCount;
}

2. C++ Code

#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int numUniqueEmails(vector<string>& emails) {
        unordered_set<string> unique;
        unique.reserve(emails.size() * 2); // reduce rehashing
        
        for (string &email : emails) {
            string normalized;
            normalized.reserve(email.size()); // avoid reallocations
            
            int i = 0, n = email.size();
            
            // process local name
            while (i < n && email[i] != '@') {
                if (email[i] == '+') {
                    while (i < n && email[i] != '@') i++; // skip rest
                    break;
                }
                if (email[i] != '.') {
                    normalized.push_back(email[i]);
                }
                i++;
            }
            
            // copy domain part (from '@' till end)
            while (i < n) {
                normalized.push_back(email[i]);
                i++;
            }
            
            unique.insert(move(normalized)); // avoid extra copy
        }
        
        return unique.size();
    }
};


